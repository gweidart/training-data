[@-1,0:5='pragma',<21>,1:0]
[@-1,7:14='solidity',<22>,1:7]
[@-1,16:21='0.4.18',<25>,1:16]
[@-1,22:22=';',<29>,1:22]
[@-1,121:127='library',<64>,7:0]
[@-1,129:136='SafeMath',<125>,7:8]
[@-1,138:138='{',<32>,7:17]
[@-1,145:152='function',<65>,8:4]
[@-1,154:156='mul',<125>,8:13]
[@-1,157:157='(',<30>,8:16]
[@-1,158:164='uint256',<119>,8:17]
[@-1,166:166='a',<125>,8:25]
[@-1,167:167=',',<59>,8:26]
[@-1,169:175='uint256',<119>,8:28]
[@-1,177:177='b',<125>,8:36]
[@-1,178:178=')',<31>,8:37]
[@-1,180:187='internal',<93>,8:39]
[@-1,189:192='pure',<95>,8:48]
[@-1,194:200='returns',<66>,8:53]
[@-1,202:202='(',<30>,8:61]
[@-1,203:209='uint256',<119>,8:62]
[@-1,210:210=')',<31>,8:69]
[@-1,212:212='{',<32>,8:71]
[@-1,223:224='if',<71>,9:8]
[@-1,226:226='(',<30>,9:11]
[@-1,227:227='a',<125>,9:12]
[@-1,229:230='==',<49>,9:14]
[@-1,232:232='0',<127>,9:17]
[@-1,233:233=')',<31>,9:18]
[@-1,235:235='{',<32>,9:20]
[@-1,250:255='return',<84>,10:12]
[@-1,257:257='0',<127>,10:19]
[@-1,258:258=';',<29>,10:20]
[@-1,269:269='}',<33>,11:8]
[@-1,280:286='uint256',<119>,12:8]
[@-1,288:288='c',<125>,12:16]
[@-1,290:290='=',<36>,12:18]
[@-1,292:292='a',<125>,12:20]
[@-1,294:294='*',<39>,12:22]
[@-1,296:296='b',<125>,12:24]
[@-1,297:297=';',<29>,12:25]
[@-1,308:313='assert',<125>,13:8]
[@-1,314:314='(',<30>,13:14]
[@-1,315:315='c',<125>,13:15]
[@-1,317:317='/',<40>,13:17]
[@-1,319:319='a',<125>,13:19]
[@-1,321:322='==',<49>,13:21]
[@-1,324:324='b',<125>,13:24]
[@-1,325:325=')',<31>,13:25]
[@-1,326:326=';',<29>,13:26]
[@-1,337:342='return',<84>,14:8]
[@-1,344:344='c',<125>,14:15]
[@-1,345:345=';',<29>,14:16]
[@-1,352:352='}',<33>,15:4]
[@-1,361:368='function',<65>,17:4]
[@-1,370:372='div',<125>,17:13]
[@-1,373:373='(',<30>,17:16]
[@-1,374:380='uint256',<119>,17:17]
[@-1,382:382='a',<125>,17:25]
[@-1,383:383=',',<59>,17:26]
[@-1,385:391='uint256',<119>,17:28]
[@-1,393:393='b',<125>,17:36]
[@-1,394:394=')',<31>,17:37]
[@-1,396:403='internal',<93>,17:39]
[@-1,405:408='pure',<95>,17:48]
[@-1,410:416='returns',<66>,17:53]
[@-1,418:418='(',<30>,17:61]
[@-1,419:425='uint256',<119>,17:62]
[@-1,426:426=')',<31>,17:69]
[@-1,428:428='{',<32>,17:71]
[@-1,518:524='uint256',<119>,19:8]
[@-1,526:526='c',<125>,19:16]
[@-1,528:528='=',<36>,19:18]
[@-1,530:530='a',<125>,19:20]
[@-1,532:532='/',<40>,19:22]
[@-1,534:534='b',<125>,19:24]
[@-1,535:535=';',<29>,19:25]
[@-1,633:638='return',<84>,21:8]
[@-1,640:640='c',<125>,21:15]
[@-1,641:641=';',<29>,21:16]
[@-1,648:648='}',<33>,22:4]
[@-1,657:664='function',<65>,24:4]
[@-1,666:668='sub',<125>,24:13]
[@-1,669:669='(',<30>,24:16]
[@-1,670:676='uint256',<119>,24:17]
[@-1,678:678='a',<125>,24:25]
[@-1,679:679=',',<59>,24:26]
[@-1,681:687='uint256',<119>,24:28]
[@-1,689:689='b',<125>,24:36]
[@-1,690:690=')',<31>,24:37]
[@-1,692:699='internal',<93>,24:39]
[@-1,701:704='pure',<95>,24:48]
[@-1,706:712='returns',<66>,24:53]
[@-1,714:714='(',<30>,24:61]
[@-1,715:721='uint256',<119>,24:62]
[@-1,722:722=')',<31>,24:69]
[@-1,724:724='{',<32>,24:71]
[@-1,735:740='assert',<125>,25:8]
[@-1,741:741='(',<30>,25:14]
[@-1,742:742='b',<125>,25:15]
[@-1,744:745='<=',<47>,25:17]
[@-1,747:747='a',<125>,25:20]
[@-1,748:748=')',<31>,25:21]
[@-1,749:749=';',<29>,25:22]
[@-1,760:765='return',<84>,26:8]
[@-1,767:767='a',<125>,26:15]
[@-1,769:769='-',<38>,26:17]
[@-1,771:771='b',<125>,26:19]
[@-1,772:772=';',<29>,26:20]
[@-1,779:779='}',<33>,27:4]
[@-1,788:795='function',<65>,29:4]
[@-1,797:799='add',<125>,29:13]
[@-1,800:800='(',<30>,29:16]
[@-1,801:807='uint256',<119>,29:17]
[@-1,809:809='a',<125>,29:25]
[@-1,810:810=',',<59>,29:26]
[@-1,812:818='uint256',<119>,29:28]
[@-1,820:820='b',<125>,29:36]
[@-1,821:821=')',<31>,29:37]
[@-1,823:830='internal',<93>,29:39]
[@-1,832:835='pure',<95>,29:48]
[@-1,837:843='returns',<66>,29:53]
[@-1,845:845='(',<30>,29:61]
[@-1,846:852='uint256',<119>,29:62]
[@-1,853:853=')',<31>,29:69]
[@-1,855:855='{',<32>,29:71]
[@-1,866:872='uint256',<119>,30:8]
[@-1,874:874='c',<125>,30:16]
[@-1,876:876='=',<36>,30:18]
[@-1,878:878='a',<125>,30:20]
[@-1,880:880='+',<37>,30:22]
[@-1,882:882='b',<125>,30:24]
[@-1,883:883=';',<29>,30:25]
[@-1,894:899='assert',<125>,31:8]
[@-1,900:900='(',<30>,31:14]
[@-1,901:901='c',<125>,31:15]
[@-1,903:904='>=',<48>,31:17]
[@-1,906:906='a',<125>,31:20]
[@-1,907:907=')',<31>,31:21]
[@-1,908:908=';',<29>,31:22]
[@-1,919:924='return',<84>,32:8]
[@-1,926:926='c',<125>,32:15]
[@-1,927:927=';',<29>,32:16]
[@-1,934:934='}',<33>,33:4]
[@-1,937:937='}',<33>,34:0]
[@-1,942:948='library',<64>,36:0]
[@-1,950:958='MathUtils',<125>,36:8]
[@-1,960:960='{',<32>,36:18]
[@-1,967:971='using',<104>,37:4]
[@-1,973:980='SafeMath',<125>,37:10]
[@-1,982:984='for',<73>,37:19]
[@-1,986:992='uint256',<119>,37:23]
[@-1,993:993=';',<29>,37:30]
[@-1,1052:1058='uint256',<119>,40:4]
[@-1,1060:1065='public',<91>,40:12]
[@-1,1067:1074='constant',<98>,40:19]
[@-1,1076:1087='PERC_DIVISOR',<125>,40:28]
[@-1,1089:1089='=',<36>,40:41]
[@-1,1091:1097='1000000',<127>,40:43]
[@-1,1098:1098=';',<29>,40:50]
[@-1,1271:1278='function',<65>,46:4]
[@-1,1280:1288='validPerc',<125>,46:13]
[@-1,1289:1289='(',<30>,46:22]
[@-1,1290:1296='uint256',<119>,46:23]
[@-1,1298:1304='_amount',<125>,46:31]
[@-1,1305:1305=')',<31>,46:38]
[@-1,1307:1314='internal',<93>,46:40]
[@-1,1316:1319='pure',<95>,46:49]
[@-1,1321:1327='returns',<66>,46:54]
[@-1,1329:1329='(',<30>,46:62]
[@-1,1330:1333='bool',<2>,46:63]
[@-1,1334:1334=')',<31>,46:67]
[@-1,1336:1336='{',<32>,46:69]
[@-1,1347:1352='return',<84>,47:8]
[@-1,1354:1360='_amount',<125>,47:15]
[@-1,1362:1363='<=',<47>,47:23]
[@-1,1365:1376='PERC_DIVISOR',<125>,47:26]
[@-1,1377:1377=';',<29>,47:38]
[@-1,1384:1384='}',<33>,48:4]
[@-1,1707:1714='function',<65>,56:4]
[@-1,1716:1721='percOf',<125>,56:13]
[@-1,1722:1722='(',<30>,56:19]
[@-1,1723:1729='uint256',<119>,56:20]
[@-1,1731:1737='_amount',<125>,56:28]
[@-1,1738:1738=',',<59>,56:35]
[@-1,1740:1746='uint256',<119>,56:37]
[@-1,1748:1755='_fracNum',<125>,56:45]
[@-1,1756:1756=',',<59>,56:53]
[@-1,1758:1764='uint256',<119>,56:55]
[@-1,1766:1775='_fracDenom',<125>,56:63]
[@-1,1776:1776=')',<31>,56:73]
[@-1,1778:1785='internal',<93>,56:75]
[@-1,1787:1790='pure',<95>,56:84]
[@-1,1792:1798='returns',<66>,56:89]
[@-1,1800:1800='(',<30>,56:97]
[@-1,1801:1807='uint256',<119>,56:98]
[@-1,1808:1808=')',<31>,56:105]
[@-1,1810:1810='{',<32>,56:107]
[@-1,1821:1826='return',<84>,57:8]
[@-1,1828:1834='_amount',<125>,57:15]
[@-1,1835:1835='.',<60>,57:22]
[@-1,1836:1838='mul',<125>,57:23]
[@-1,1839:1839='(',<30>,57:26]
[@-1,1840:1849='percPoints',<125>,57:27]
[@-1,1850:1850='(',<30>,57:37]
[@-1,1851:1858='_fracNum',<125>,57:38]
[@-1,1859:1859=',',<59>,57:46]
[@-1,1861:1870='_fracDenom',<125>,57:48]
[@-1,1871:1871=')',<31>,57:58]
[@-1,1872:1872=')',<31>,57:59]
[@-1,1873:1873='.',<60>,57:60]
[@-1,1874:1876='div',<125>,57:61]
[@-1,1877:1877='(',<30>,57:64]
[@-1,1878:1889='PERC_DIVISOR',<125>,57:65]
[@-1,1890:1890=')',<31>,57:77]
[@-1,1891:1891=';',<29>,57:78]
[@-1,1898:1898='}',<33>,58:4]
[@-1,2198:2205='function',<65>,65:4]
[@-1,2207:2212='percOf',<125>,65:13]
[@-1,2213:2213='(',<30>,65:19]
[@-1,2214:2220='uint256',<119>,65:20]
[@-1,2222:2228='_amount',<125>,65:28]
[@-1,2229:2229=',',<59>,65:35]
[@-1,2231:2237='uint256',<119>,65:37]
[@-1,2239:2246='_fracNum',<125>,65:45]
[@-1,2247:2247=')',<31>,65:53]
[@-1,2249:2256='internal',<93>,65:55]
[@-1,2258:2261='pure',<95>,65:64]
[@-1,2263:2269='returns',<66>,65:69]
[@-1,2271:2271='(',<30>,65:77]
[@-1,2272:2278='uint256',<119>,65:78]
[@-1,2279:2279=')',<31>,65:85]
[@-1,2281:2281='{',<32>,65:87]
[@-1,2292:2297='return',<84>,66:8]
[@-1,2299:2305='_amount',<125>,66:15]
[@-1,2306:2306='.',<60>,66:22]
[@-1,2307:2309='mul',<125>,66:23]
[@-1,2310:2310='(',<30>,66:26]
[@-1,2311:2318='_fracNum',<125>,66:27]
[@-1,2319:2319=')',<31>,66:35]
[@-1,2320:2320='.',<60>,66:36]
[@-1,2321:2323='div',<125>,66:37]
[@-1,2324:2324='(',<30>,66:40]
[@-1,2325:2336='PERC_DIVISOR',<125>,66:41]
[@-1,2337:2337=')',<31>,66:53]
[@-1,2338:2338=';',<29>,66:54]
[@-1,2345:2345='}',<33>,67:4]
[@-1,2582:2589='function',<65>,74:4]
[@-1,2591:2600='percPoints',<125>,74:13]
[@-1,2601:2601='(',<30>,74:23]
[@-1,2602:2608='uint256',<119>,74:24]
[@-1,2610:2617='_fracNum',<125>,74:32]
[@-1,2618:2618=',',<59>,74:40]
[@-1,2620:2626='uint256',<119>,74:42]
[@-1,2628:2637='_fracDenom',<125>,74:50]
[@-1,2638:2638=')',<31>,74:60]
[@-1,2640:2647='internal',<93>,74:62]
[@-1,2649:2652='pure',<95>,74:71]
[@-1,2654:2660='returns',<66>,74:76]
[@-1,2662:2662='(',<30>,74:84]
[@-1,2663:2669='uint256',<119>,74:85]
[@-1,2670:2670=')',<31>,74:92]
[@-1,2672:2672='{',<32>,74:94]
[@-1,2683:2688='return',<84>,75:8]
[@-1,2690:2697='_fracNum',<125>,75:15]
[@-1,2698:2698='.',<60>,75:23]
[@-1,2699:2701='mul',<125>,75:24]
[@-1,2702:2702='(',<30>,75:27]
[@-1,2703:2714='PERC_DIVISOR',<125>,75:28]
[@-1,2715:2715=')',<31>,75:40]
[@-1,2716:2716='.',<60>,75:41]
[@-1,2717:2719='div',<125>,75:42]
[@-1,2720:2720='(',<30>,75:45]
[@-1,2721:2730='_fracDenom',<125>,75:46]
[@-1,2731:2731=')',<31>,75:56]
[@-1,2732:2732=';',<29>,75:57]
[@-1,2739:2739='}',<33>,76:4]
[@-1,2742:2742='}',<33>,77:0]
[@-1,2914:2920='library',<64>,84:0]
[@-1,2922:2932='MerkleProof',<125>,84:8]
[@-1,2934:2934='{',<32>,84:20]
[@-1,3303:3310='function',<65>,92:2]
[@-1,3312:3322='verifyProof',<125>,92:11]
[@-1,3323:3323='(',<30>,92:22]
[@-1,3324:3328='bytes',<116>,92:23]
[@-1,3330:3335='_proof',<125>,92:29]
[@-1,3336:3336=',',<59>,92:35]
[@-1,3338:3344='bytes32',<115>,92:37]
[@-1,3346:3350='_root',<125>,92:45]
[@-1,3351:3351=',',<59>,92:50]
[@-1,3353:3359='bytes32',<115>,92:52]
[@-1,3361:3365='_leaf',<125>,92:60]
[@-1,3366:3366=')',<31>,92:65]
[@-1,3368:3373='public',<91>,92:67]
[@-1,3375:3378='pure',<95>,92:74]
[@-1,3380:3386='returns',<66>,92:79]
[@-1,3388:3388='(',<30>,92:87]
[@-1,3389:3392='bool',<2>,92:88]
[@-1,3393:3393=')',<31>,92:92]
[@-1,3395:3395='{',<32>,92:94]
[@-1,3452:3453='if',<71>,94:4]
[@-1,3455:3455='(',<30>,94:7]
[@-1,3456:3461='_proof',<125>,94:8]
[@-1,3462:3462='.',<60>,94:14]
[@-1,3463:3468='length',<125>,94:15]
[@-1,3470:3470='%',<41>,94:22]
[@-1,3472:3473='32',<127>,94:24]
[@-1,3475:3476='!=',<50>,94:27]
[@-1,3478:3478='0',<127>,94:30]
[@-1,3479:3479=')',<31>,94:31]
[@-1,3481:3486='return',<84>,94:33]
[@-1,3488:3492='false',<125>,94:40]
[@-1,3493:3493=';',<29>,94:45]
[@-1,3502:3508='bytes32',<115>,96:4]
[@-1,3510:3521='proofElement',<125>,96:12]
[@-1,3522:3522=';',<29>,96:24]
[@-1,3529:3535='bytes32',<115>,97:4]
[@-1,3537:3548='computedHash',<125>,97:12]
[@-1,3550:3550='=',<36>,97:25]
[@-1,3552:3556='_leaf',<125>,97:27]
[@-1,3557:3557=';',<29>,97:32]
[@-1,3566:3568='for',<73>,99:4]
[@-1,3570:3570='(',<30>,99:8]
[@-1,3571:3577='uint256',<119>,99:9]
[@-1,3579:3579='i',<125>,99:17]
[@-1,3581:3581='=',<36>,99:19]
[@-1,3583:3584='32',<127>,99:21]
[@-1,3585:3585=';',<29>,99:23]
[@-1,3587:3587='i',<125>,99:25]
[@-1,3589:3590='<=',<47>,99:27]
[@-1,3592:3597='_proof',<125>,99:30]
[@-1,3598:3598='.',<60>,99:36]
[@-1,3599:3604='length',<125>,99:37]
[@-1,3605:3605=';',<29>,99:43]
[@-1,3607:3607='i',<125>,99:45]
[@-1,3609:3610='+=',<16>,99:47]
[@-1,3612:3613='32',<127>,99:50]
[@-1,3614:3614=')',<31>,99:52]
[@-1,3616:3616='{',<32>,99:54]
[@-1,3625:3632='assembly',<79>,100:6]
[@-1,3634:3634='{',<32>,100:15]
[@-1,3695:3706='proofElement',<125>,102:8]
[@-1,3708:3708=':',<58>,102:21]
[@-1,3709:3709='=',<36>,102:22]
[@-1,3711:3715='mload',<125>,102:24]
[@-1,3716:3716='(',<30>,102:29]
[@-1,3717:3719='add',<125>,102:30]
[@-1,3720:3720='(',<30>,102:33]
[@-1,3721:3726='_proof',<125>,102:34]
[@-1,3727:3727=',',<59>,102:40]
[@-1,3729:3729='i',<125>,102:42]
[@-1,3730:3730=')',<31>,102:43]
[@-1,3731:3731=')',<31>,102:44]
[@-1,3740:3740='}',<33>,103:6]
[@-1,3751:3752='if',<71>,105:6]
[@-1,3754:3754='(',<30>,105:9]
[@-1,3755:3766='computedHash',<125>,105:10]
[@-1,3768:3768='<',<45>,105:23]
[@-1,3770:3781='proofElement',<125>,105:25]
[@-1,3782:3782=')',<31>,105:37]
[@-1,3784:3784='{',<32>,105:39]
[@-1,3866:3877='computedHash',<125>,107:8]
[@-1,3879:3879='=',<36>,107:21]
[@-1,3881:3889='keccak256',<125>,107:23]
[@-1,3890:3890='(',<30>,107:32]
[@-1,3891:3902='computedHash',<125>,107:33]
[@-1,3903:3903=',',<59>,107:45]
[@-1,3905:3916='proofElement',<125>,107:47]
[@-1,3917:3917=')',<31>,107:59]
[@-1,3918:3918=';',<29>,107:60]
[@-1,3927:3927='}',<33>,108:6]
[@-1,3929:3932='else',<72>,108:8]
[@-1,3934:3934='{',<32>,108:13]
[@-1,4016:4027='computedHash',<125>,110:8]
[@-1,4029:4029='=',<36>,110:21]
[@-1,4031:4039='keccak256',<125>,110:23]
[@-1,4040:4040='(',<30>,110:32]
[@-1,4041:4052='proofElement',<125>,110:33]
[@-1,4053:4053=',',<59>,110:45]
[@-1,4055:4066='computedHash',<125>,110:47]
[@-1,4067:4067=')',<31>,110:59]
[@-1,4068:4068=';',<29>,110:60]
[@-1,4077:4077='}',<33>,111:6]
[@-1,4084:4084='}',<33>,112:4]
[@-1,4165:4170='return',<84>,115:4]
[@-1,4172:4183='computedHash',<125>,115:11]
[@-1,4185:4186='==',<49>,115:24]
[@-1,4188:4192='_root',<125>,115:27]
[@-1,4193:4193=';',<29>,115:32]
[@-1,4198:4198='}',<33>,116:2]
[@-1,4201:4201='}',<33>,117:0]
[@-1,4346:4352='library',<64>,124:0]
[@-1,4354:4363='ECRecovery',<125>,124:8]
[@-1,4365:4365='{',<32>,124:19]
[@-1,4649:4656='function',<65>,131:2]
[@-1,4658:4664='recover',<125>,131:11]
[@-1,4665:4665='(',<30>,131:18]
[@-1,4666:4672='bytes32',<115>,131:19]
[@-1,4674:4677='hash',<125>,131:27]
[@-1,4678:4678=',',<59>,131:31]
[@-1,4680:4684='bytes',<116>,131:33]
[@-1,4686:4688='sig',<125>,131:39]
[@-1,4689:4689=')',<31>,131:42]
[@-1,4691:4696='public',<91>,131:44]
[@-1,4698:4701='pure',<95>,131:51]
[@-1,4703:4709='returns',<66>,131:56]
[@-1,4711:4711='(',<30>,131:64]
[@-1,4712:4718='address',<1>,131:65]
[@-1,4719:4719=')',<31>,131:72]
[@-1,4721:4721='{',<32>,131:74]
[@-1,4728:4734='bytes32',<115>,132:4]
[@-1,4736:4736='r',<125>,132:12]
[@-1,4737:4737=';',<29>,132:13]
[@-1,4744:4750='bytes32',<115>,133:4]
[@-1,4752:4752='s',<125>,133:12]
[@-1,4753:4753=';',<29>,133:13]
[@-1,4760:4764='uint8',<119>,134:4]
[@-1,4766:4766='v',<125>,134:10]
[@-1,4767:4767=';',<29>,134:11]
[@-1,4810:4811='if',<71>,137:4]
[@-1,4813:4813='(',<30>,137:7]
[@-1,4814:4816='sig',<125>,137:8]
[@-1,4817:4817='.',<60>,137:11]
[@-1,4818:4823='length',<125>,137:12]
[@-1,4825:4826='!=',<50>,137:19]
[@-1,4828:4829='65',<127>,137:22]
[@-1,4830:4830=')',<31>,137:24]
[@-1,4832:4832='{',<32>,137:26]
[@-1,4841:4846='return',<84>,138:6]
[@-1,4848:4848='(',<30>,138:13]
[@-1,4849:4855='address',<1>,138:14]
[@-1,4856:4856='(',<30>,138:21]
[@-1,4857:4857='0',<127>,138:22]
[@-1,4858:4858=')',<31>,138:23]
[@-1,4859:4859=')',<31>,138:24]
[@-1,4860:4860=';',<29>,138:25]
[@-1,4867:4867='}',<33>,139:4]
[@-1,4929:4936='assembly',<79>,142:4]
[@-1,4938:4938='{',<32>,142:13]
[@-1,4947:4947='r',<125>,143:6]
[@-1,4949:4949=':',<58>,143:8]
[@-1,4950:4950='=',<36>,143:9]
[@-1,4952:4956='mload',<125>,143:11]
[@-1,4957:4957='(',<30>,143:16]
[@-1,4958:4960='add',<125>,143:17]
[@-1,4961:4961='(',<30>,143:20]
[@-1,4962:4964='sig',<125>,143:21]
[@-1,4965:4965=',',<59>,143:24]
[@-1,4967:4968='32',<127>,143:26]
[@-1,4969:4969=')',<31>,143:28]
[@-1,4970:4970=')',<31>,143:29]
[@-1,4979:4979='s',<125>,144:6]
[@-1,4981:4981=':',<58>,144:8]
[@-1,4982:4982='=',<36>,144:9]
[@-1,4984:4988='mload',<125>,144:11]
[@-1,4989:4989='(',<30>,144:16]
[@-1,4990:4992='add',<125>,144:17]
[@-1,4993:4993='(',<30>,144:20]
[@-1,4994:4996='sig',<125>,144:21]
[@-1,4997:4997=',',<59>,144:24]
[@-1,4999:5000='64',<127>,144:26]
[@-1,5001:5001=')',<31>,144:28]
[@-1,5002:5002=')',<31>,144:29]
[@-1,5011:5011='v',<125>,145:6]
[@-1,5013:5013=':',<58>,145:8]
[@-1,5014:5014='=',<36>,145:9]
[@-1,5016:5019='byte',<5>,145:11]
[@-1,5020:5020='(',<30>,145:15]
[@-1,5021:5021='0',<127>,145:16]
[@-1,5022:5022=',',<59>,145:17]
[@-1,5024:5028='mload',<125>,145:19]
[@-1,5029:5029='(',<30>,145:24]
[@-1,5030:5032='add',<125>,145:25]
[@-1,5033:5033='(',<30>,145:28]
[@-1,5034:5036='sig',<125>,145:29]
[@-1,5037:5037=',',<59>,145:32]
[@-1,5039:5040='96',<127>,145:34]
[@-1,5041:5041=')',<31>,145:36]
[@-1,5042:5042=')',<31>,145:37]
[@-1,5043:5043=')',<31>,145:38]
[@-1,5050:5050='}',<33>,146:4]
[@-1,5147:5148='if',<71>,149:4]
[@-1,5150:5150='(',<30>,149:7]
[@-1,5151:5151='v',<125>,149:8]
[@-1,5153:5153='<',<45>,149:10]
[@-1,5155:5156='27',<127>,149:12]
[@-1,5157:5157=')',<31>,149:14]
[@-1,5159:5159='{',<32>,149:16]
[@-1,5168:5168='v',<125>,150:6]
[@-1,5170:5171='+=',<16>,150:8]
[@-1,5173:5174='27',<127>,150:11]
[@-1,5175:5175=';',<29>,150:13]
[@-1,5182:5182='}',<33>,151:4]
[@-1,5251:5252='if',<71>,154:4]
[@-1,5254:5254='(',<30>,154:7]
[@-1,5255:5255='v',<125>,154:8]
[@-1,5257:5258='!=',<50>,154:10]
[@-1,5260:5261='27',<127>,154:13]
[@-1,5263:5264='&&',<42>,154:16]
[@-1,5266:5266='v',<125>,154:19]
[@-1,5268:5269='!=',<50>,154:21]
[@-1,5271:5272='28',<127>,154:24]
[@-1,5273:5273=')',<31>,154:26]
[@-1,5275:5275='{',<32>,154:28]
[@-1,5284:5289='return',<84>,155:6]
[@-1,5291:5291='(',<30>,155:13]
[@-1,5292:5298='address',<1>,155:14]
[@-1,5299:5299='(',<30>,155:21]
[@-1,5300:5300='0',<127>,155:22]
[@-1,5301:5301=')',<31>,155:23]
[@-1,5302:5302=')',<31>,155:24]
[@-1,5303:5303=';',<29>,155:25]
[@-1,5310:5310='}',<33>,156:4]
[@-1,5312:5315='else',<72>,156:6]
[@-1,5317:5317='{',<32>,156:11]
[@-1,5326:5331='return',<84>,157:6]
[@-1,5333:5341='ecrecover',<125>,157:13]
[@-1,5342:5342='(',<30>,157:22]
[@-1,5343:5346='hash',<125>,157:23]
[@-1,5347:5347=',',<59>,157:27]
[@-1,5349:5349='v',<125>,157:29]
[@-1,5350:5350=',',<59>,157:30]
[@-1,5352:5352='r',<125>,157:32]
[@-1,5353:5353=',',<59>,157:33]
[@-1,5355:5355='s',<125>,157:35]
[@-1,5356:5356=')',<31>,157:36]
[@-1,5357:5357=';',<29>,157:37]
[@-1,5364:5364='}',<33>,158:4]
[@-1,5369:5369='}',<33>,159:2]
[@-1,5374:5374='}',<33>,161:0]
[@-1,5379:5385='library',<64>,163:0]
[@-1,5387:5392='JobLib',<125>,163:8]
[@-1,5394:5394='{',<32>,163:15]
[@-1,5401:5405='using',<104>,164:4]
[@-1,5407:5414='SafeMath',<125>,164:10]
[@-1,5416:5418='for',<73>,164:19]
[@-1,5420:5426='uint256',<119>,164:23]
[@-1,5427:5427=';',<29>,164:30]
[@-1,5528:5533='string',<3>,166:4]
[@-1,5535:5542='constant',<98>,166:11]
[@-1,5544:5563='PERSONAL_HASH_PREFIX',<125>,166:20]
[@-1,5565:5565='=',<36>,166:41]
[@-1,5570:5573='0019',<127>,166:46]
[@-1,5574:5581='Ethereum',<125>,166:50]
[@-1,5583:5588='Signed',<125>,166:59]
[@-1,5590:5596='Message',<125>,166:66]
[@-1,5597:5597=':',<58>,166:73]
[@-1,5599:5601='n32',<125>,166:75]
[@-1,5602:12257='";\r\n    // # of bytes used to store a video profile identifier as a utf8 encoded string\r\n    // Video profile identifier is currently stored as bytes4(keccak256(PROFILE_NAME))\r\n    // We use 2 * 4 = 8 bytes because we store the bytes in a utf8 encoded string so\r\n    // the identifiers can be easily parsed off-chain\r\n    uint8 constant VIDEO_PROFILE_SIZE = 8;\r\n\r\n    /*\r\n     * @dev Checks if a transcoding options string is valid\r\n     * A transcoding options string is composed of video profile ids so its length\r\n     * must be a multiple of VIDEO_PROFILE_SIZE\r\n     * @param _transcodingOptions Transcoding options string\r\n     */\r\n    function validTranscodingOptions(string _transcodingOptions) public pure returns (bool) {\r\n        uint256 transcodingOptionsLength = bytes(_transcodingOptions).length;\r\n        return transcodingOptionsLength > 0 && transcodingOptionsLength % VIDEO_PROFILE_SIZE == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Computes the amount of fees given total segments, total number of profiles and price per segment\r\n     * @param _totalSegments # of segments\r\n     * @param _transcodingOptions String containing video profiles for a job\r\n     * @param _pricePerSegment Price in LPT base units per segment\r\n     */\r\n    function calcFees(uint256 _totalSegments, string _transcodingOptions, uint256 _pricePerSegment) public pure returns (uint256) {\r\n        // Calculate total profiles defined in the transcoding options string\r\n        uint256 totalProfiles = bytes(_transcodingOptions).length.div(VIDEO_PROFILE_SIZE);\r\n        return _totalSegments.mul(totalProfiles).mul(_pricePerSegment);\r\n    }\r\n\r\n    /*\r\n     * Computes whether a segment is eligible for verification based on the last call to claimWork()\r\n     * @param _segmentNumber Sequence number of segment in stream\r\n     * @param _segmentRange Range of segments claimed\r\n     * @param _challengeBlock Block afer the block when claimWork() was called\r\n     * @param _challengeBlockHash Block hash of challenge block\r\n     * @param _verificationRate Rate at which a particular segment should be verified\r\n     */\r\n    function shouldVerifySegment(\r\n        uint256 _segmentNumber,\r\n        uint256[2] _segmentRange,\r\n        uint256 _challengeBlock,\r\n        bytes32 _challengeBlockHash,\r\n        uint64 _verificationRate\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        // Segment must be in segment range\r\n        if (_segmentNumber < _segmentRange[0] || _segmentNumber > _segmentRange[1]) {\r\n            return false;\r\n        }\r\n\r\n        // Use block hash and block number of the block after a claim to determine if a segment\r\n        // should be verified\r\n        if (uint256(keccak256(_challengeBlock, _challengeBlockHash, _segmentNumber)) % _verificationRate == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if a segment was signed by a broadcaster address\r\n     * @param _streamId Stream ID for the segment\r\n     * @param _segmentNumber Sequence number of segment in the stream\r\n     * @param _dataHash Hash of segment data\r\n     * @param _broadcasterSig Broadcaster signature over h(streamId, segmentNumber, dataHash)\r\n     * @param _broadcaster Broadcaster address\r\n     */\r\n    function validateBroadcasterSig(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes _broadcasterSig,\r\n        address _broadcaster\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return ECRecovery.recover(personalSegmentHash(_streamId, _segmentNumber, _dataHash), _broadcasterSig) == _broadcaster;\r\n    }\r\n\r\n    /*\r\n     * @dev Checks if a transcode receipt hash was included in a committed merkle root\r\n     * @param _streamId StreamID for the segment\r\n     * @param _segmentNumber Sequence number of segment in the stream\r\n     * @param _dataHash Hash of segment data\r\n     * @param _transcodedDataHash Hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster signature over h(streamId, segmentNumber, dataHash)\r\n     * @param _broadcaster Broadcaster address\r\n     */\r\n    function validateReceipt(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes32 _transcodedDataHash,\r\n        bytes _broadcasterSig,\r\n        bytes _proof,\r\n        bytes32 _claimRoot\r\n    )\r\n        public\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return MerkleProof.verifyProof(_proof, _claimRoot, transcodeReceiptHash(_streamId, _segmentNumber, _dataHash, _transcodedDataHash, _broadcasterSig));\r\n    }\r\n\r\n    /*\r\n     * Compute the hash of a segment\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addressed storage hash of segment data\r\n     */\r\n    function segmentHash(string _streamId, uint256 _segmentNumber, bytes32 _dataHash) public pure returns (bytes32) {\r\n        return keccak256(_streamId, _segmentNumber, _dataHash);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute the personal segment hash of a segment. Hashes the concatentation of the personal hash prefix and the segment hash\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addrssed storage hash of segment data\r\n     */\r\n    function personalSegmentHash(string _streamId, uint256 _segmentNumber, bytes32 _dataHash) public pure returns (bytes32) {\r\n        bytes memory prefixBytes = bytes(PERSONAL_HASH_PREFIX);\r\n\r\n        return keccak256(prefixBytes, segmentHash(_streamId, _segmentNumber, _dataHash));\r\n    }\r\n\r\n    /*\r\n     * Compute the hash of a transcode receipt\r\n     * @param _streamId Stream identifier\r\n     * @param _segmentSequenceNumber Segment sequence number in stream\r\n     * @param _dataHash Content-addressed storage hash of segment data\r\n     * @param _transcodedDataHash Content-addressed storage hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster's signature over segment\r\n     */\r\n    function transcodeReceiptHash(\r\n        string _streamId,\r\n        uint256 _segmentNumber,\r\n        bytes32 _dataHash,\r\n        bytes32 _transcodedDataHash,\r\n        bytes _broadcasterSig\r\n    )\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(_streamId, _segmentNumber, _dataHash, _transcodedDataHash, _broadcasterSig);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of "',<126>,166:78]
[@-1,12258:12261='user',<125>,324:53]
[@-1,12263:12273='permissions',<125>,324:58]
[@-1,12274:24601='".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\ncontract IController is Pausable {\r\n    event SetContractInfo(bytes32 id, address contractAddress, bytes20 gitCommitHash);\r\n\r\n    function setContractInfo(bytes32 _id, address _contractAddress, bytes20 _gitCommitHash) external;\r\n    function updateController(bytes32 _id, address _controller) external;\r\n    function getContract(bytes32 _id) public view returns (address);\r\n}\r\n\r\ncontract IManager {\r\n    event SetController(address controller);\r\n    event ParameterUpdate(string param);\r\n\r\n    function setController(address _controller) external;\r\n}\r\n\r\ncontract Manager is IManager {\r\n    // Controller that contract is registered with\r\n    IController public controller;\r\n\r\n    // Check if sender is controller\r\n    modifier onlyController() {\r\n        require(msg.sender == address(controller));\r\n        _;\r\n    }\r\n\r\n    // Check if sender is controller owner\r\n    modifier onlyControllerOwner() {\r\n        require(msg.sender == controller.owner());\r\n        _;\r\n    }\r\n\r\n    // Check if controller is not paused\r\n    modifier whenSystemNotPaused() {\r\n        require(!controller.paused());\r\n        _;\r\n    }\r\n\r\n    // Check if controller is paused\r\n    modifier whenSystemPaused() {\r\n        require(controller.paused());\r\n        _;\r\n    }\r\n\r\n    function Manager(address _controller) public {\r\n        controller = IController(_controller);\r\n    }\r\n\r\n    /*\r\n     * @dev Set controller. Only callable by current controller\r\n     * @param _controller Controller contract address\r\n     */\r\n    function setController(address _controller) external onlyController {\r\n        controller = IController(_controller);\r\n\r\n        SetController(_controller);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ManagerProxyTarget\r\n * @dev The base contract that target contracts used by a proxy contract should inherit from\r\n * Note: Both the target contract and the proxy contract (implemented as ManagerProxy) MUST inherit from ManagerProxyTarget in order to guarantee\r\n * that both contracts have the same storage layout. Differing storage layouts in a proxy contract and target contract can\r\n * potentially break the delegate proxy upgradeability mechanism\r\n */\r\ncontract ManagerProxyTarget is Manager {\r\n    // Used to look up target contract address in controller's registry\r\n    bytes32 public targetContractId;\r\n}\r\n\r\n/**\r\n * @title Minter interface\r\n */\r\ncontract IMinter {\r\n    // Events\r\n    event SetCurrentRewardTokens(uint256 currentMintableTokens, uint256 currentInflation);\r\n\r\n    // External functions\r\n    function createReward(uint256 _fracNum, uint256 _fracDenom) external returns (uint256);\r\n    function trustedTransferTokens(address _to, uint256 _amount) external;\r\n    function trustedBurnTokens(uint256 _amount) external;\r\n    function trustedWithdrawETH(address _to, uint256 _amount) external;\r\n    function depositETH() external payable returns (bool);\r\n    function setCurrentRewardTokens() external;\r\n\r\n    // Public functions\r\n    function getController() public view returns (IController);\r\n}\r\n\r\n/**\r\n * @title Interface for a Verifier. Can be backed by any implementaiton including oracles or Truebit\r\n */\r\ncontract IVerifier {\r\n    function verify(\r\n                    uint256 _jobId,\r\n                    uint256 _claimId,\r\n                    uint256 _segmentNumber,\r\n                    string _transcodingOptions,\r\n                    string _dataStorageHash,\r\n                    bytes32[2] _dataHashes\r\n                    )\r\n        external\r\n        payable;\r\n\r\n    function getPrice() public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title RoundsManager interface\r\n */\r\ncontract IRoundsManager {\r\n    // Events\r\n    event NewRound(uint256 round);\r\n\r\n    // External functions\r\n    function initializeRound() external;\r\n\r\n    // Public functions\r\n    function blockNum() public view returns (uint256);\r\n    function blockHash(uint256 _block) public view returns (bytes32);\r\n    function currentRound() public view returns (uint256);\r\n    function currentRoundStartBlock() public view returns (uint256);\r\n    function currentRoundInitialized() public view returns (bool);\r\n    function currentRoundLocked() public view returns (bool);\r\n}\r\n\r\n/*\r\n * @title Interface for BondingManager\r\n */\r\ncontract IBondingManager {\r\n    event TranscoderUpdate(address indexed transcoder, uint256 pendingRewardCut, uint256 pendingFeeShare, uint256 pendingPricePerSegment, bool registered);\r\n    event TranscoderEvicted(address indexed transcoder);\r\n    event TranscoderResigned(address indexed transcoder);\r\n    event TranscoderSlashed(address indexed transcoder, address finder, uint256 penalty, uint256 finderReward);\r\n    event Reward(address indexed transcoder, uint256 amount);\r\n    event Bond(address indexed delegate, address indexed delegator);\r\n    event Unbond(address indexed delegate, address indexed delegator);\r\n    event WithdrawStake(address indexed delegator);\r\n    event WithdrawFees(address indexed delegator);\r\n\r\n    // External functions\r\n    function setActiveTranscoders() external;\r\n    function updateTranscoderWithFees(address _transcoder, uint256 _fees, uint256 _round) external;\r\n    function slashTranscoder(address _transcoder, address _finder, uint256 _slashAmount, uint256 _finderFee) external;\r\n    function electActiveTranscoder(uint256 _maxPricePerSegment, bytes32 _blockHash, uint256 _round) external view returns (address);\r\n\r\n    // Public functions\r\n    function transcoderTotalStake(address _transcoder) public view returns (uint256);\r\n    function activeTranscoderTotalStake(address _transcoder, uint256 _round) public view returns (uint256);\r\n    function isRegisteredTranscoder(address _transcoder) public view returns (bool);\r\n    function getTotalBonded() public view returns (uint256);\r\n}\r\n\r\n/*\r\n * @title Interface for contract that receives verification results\r\n */\r\ncontract IVerifiable {\r\n    // External functions\r\n    function receiveVerification(uint256 _jobId, uint256 _claimId, uint256 _segmentNumber, bool _result) external;\r\n}\r\n\r\n/*\r\n * @title Interface for JobsManager\r\n */\r\ncontract IJobsManager {\r\n    event Deposit(address indexed broadcaster, uint256 amount);\r\n    event Withdraw(address indexed broadcaster);\r\n    event NewJob(address indexed broadcaster, uint256 jobId, string streamId, string transcodingOptions, uint256 maxPricePerSegment, uint256 creationBlock);\r\n    event NewClaim(address indexed transcoder, uint256 indexed jobId, uint256 claimId);\r\n    event Verify(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 segmentNumber);\r\n    event DistributeFees(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 fees);\r\n    event PassedVerification(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 segmentNumber);\r\n    event FailedVerification(address indexed transcoder, uint256 indexed jobId, uint256 indexed claimId, uint256 segmentNumber);\r\n}\r\n\r\ncontract JobsManager is ManagerProxyTarget, IVerifiable, IJobsManager {\r\n    using SafeMath for uint256;\r\n\r\n    // % of segments to be verified. 1 / verificationRate == % to be verified\r\n    uint64 public verificationRate;\r\n\r\n    // Time after a transcoder calls claimWork() that it has to complete verification of claimed work\r\n    uint256 public verificationPeriod;\r\n\r\n    // Time after a claim's verification period during which anyone can slash the transcoder for missing a required verification\r\n    uint256 public verificationSlashingPeriod;\r\n\r\n    // % of stake slashed for failed verification\r\n    uint256 public failedVerificationSlashAmount;\r\n\r\n    // % of stake slashed for missed verification\r\n    uint256 public missedVerificationSlashAmount;\r\n\r\n    // % of stake slashed for double claiming a segment\r\n    uint256 public doubleClaimSegmentSlashAmount;\r\n\r\n    // % of of slashed amount awarded to finder\r\n    uint256 public finderFee;\r\n\r\n    struct Broadcaster {\r\n        uint256 deposit;         // Deposited tokens for jobs\r\n        uint256 withdrawBlock;   // Block at which a deposit can be withdrawn\r\n    }\r\n\r\n    // Mapping broadcaster address => broadcaster info\r\n    mapping (address => Broadcaster) public broadcasters;\r\n\r\n    // Represents a transcode job\r\n    struct Job {\r\n        uint256 jobId;                        // Unique identifer for job\r\n        string streamId;                      // Unique identifier for stream.\r\n        string transcodingOptions;            // Options used for transcoding\r\n        uint256 maxPricePerSegment;           // Max price (in LPT base units) per segment of a stream\r\n        address broadcasterAddress;           // Address of broadcaster that requestes a transcoding job\r\n        address transcoderAddress;            // Address of transcoder selected for the job\r\n        uint256 creationRound;                // Round that a job is created\r\n        uint256 creationBlock;                // Block that a job is created\r\n        uint256 endBlock;                     // Block at which the job is ended and considered inactive\r\n        Claim[] claims;                       // Claims submitted for this job\r\n        uint256 escrow;                       // Claim fees before verification and slashing periods are complete\r\n    }\r\n\r\n    // States of a job\r\n    enum JobStatus { Inactive, Active }\r\n\r\n    // Represents a transcode claim\r\n    struct Claim {\r\n        uint256 claimId;                                   // Unique identifier for claim\r\n        uint256[2] segmentRange;                           // Range of segments claimed\r\n        bytes32 claimRoot;                                 // Merkle root of segment transcode proof data\r\n        uint256 claimBlock;                                // Block number that claim was submitted\r\n        uint256 endVerificationBlock;                      // End of verification period for this claim\r\n        uint256 endVerificationSlashingBlock;              // End of verification slashing period for this claim\r\n        mapping (uint256 => bool) segmentVerifications;    // Mapping segment number => whether segment was submitted for verification\r\n        ClaimStatus status;                                // Status of claim (pending, slashed, complete)\r\n    }\r\n\r\n    // States of a transcode claim\r\n    enum ClaimStatus { Pending, Slashed, Complete }\r\n\r\n    // Transcode jobs\r\n    mapping (uint256 => Job) public jobs;\r\n    // Number of jobs created. Also used for sequential identifiers\r\n    uint256 public numJobs;\r\n\r\n    // Check if sender is Verifier\r\n    modifier onlyVerifier() {\r\n        require(msg.sender == controller.getContract(keccak256("',<126>,324:69]
[@-1,24602:24609='Verifier',<125>,653:64]
[@-1,24610:25469='")));\r\n        _;\r\n    }\r\n\r\n    // Check if job exists\r\n    modifier jobExists(uint256 _jobId) {\r\n        require(_jobId < numJobs);\r\n        _;\r\n    }\r\n\r\n    // Check if sender provided enough payment for verification\r\n    modifier sufficientPayment() {\r\n        require(msg.value >= verifier().getPrice());\r\n        _;\r\n    }\r\n\r\n    function JobsManager(address _controller) public Manager(_controller) {}\r\n\r\n    /*\r\n     * @dev Set verification rate. Only callable by the controller owner\r\n     * @param _verificationRate Verification rate such that 1 / verificationRate of segments are challenged\r\n     */\r\n    function setVerificationRate(uint64 _verificationRate) external onlyControllerOwner {\r\n        // verificationRate cannot be 0\r\n        require(_verificationRate > 0);\r\n\r\n        verificationRate = _verificationRate;\r\n\r\n        ParameterUpdate("',<126>,653:72]
[@-1,25470:25485='verificationRate',<125>,681:25]
[@-1,25486:26146='");\r\n    }\r\n\r\n    /*\r\n     * @dev Set verification period. Only callable by the controller owner\r\n     * @param _verificationPeriod Number of blocks to complete verification of claimed work\r\n     */\r\n    function setVerificationPeriod(uint256 _verificationPeriod) external onlyControllerOwner {\r\n        // Verification period + verification slashing period currently cannot be longer than 256 blocks\r\n        // because contracts can only access the last 256 blocks from\r\n        // the current block\r\n        require(_verificationPeriod.add(verificationSlashingPeriod) <= 256);\r\n\r\n        verificationPeriod = _verificationPeriod;\r\n\r\n        ParameterUpdate("',<126>,681:41]
[@-1,26147:26164='verificationPeriod',<125>,696:25]
[@-1,26165:26889='");\r\n    }\r\n\r\n    /*\r\n     * @dev Set verification slashing period. Only callable by the controller owner\r\n     * @param _verificationSlashingPeriod Number of blocks after the verification period to submit slashing proofs\r\n     */\r\n    function setVerificationSlashingPeriod(uint256 _verificationSlashingPeriod) external onlyControllerOwner {\r\n        // Verification period + verification slashing period currently cannot be longer than 256 blocks\r\n        // because contracts can only access the last 256 blocks from\r\n        // the current block\r\n        require(verificationPeriod.add(_verificationSlashingPeriod) <= 256);\r\n\r\n        verificationSlashingPeriod = _verificationSlashingPeriod;\r\n\r\n        ParameterUpdate("',<126>,696:43]
[@-1,26890:26915='verificationSlashingPeriod',<125>,711:25]
[@-1,26916:27454='");\r\n    }\r\n\r\n    /*\r\n     * @dev Set failed verification slash amount. Only callable by the controller owner\r\n     * @param _failedVerificationSlashAmount % of stake slashed for failed verification\r\n     */\r\n    function setFailedVerificationSlashAmount(uint256 _failedVerificationSlashAmount) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_failedVerificationSlashAmount));\r\n\r\n        failedVerificationSlashAmount = _failedVerificationSlashAmount;\r\n\r\n        ParameterUpdate("',<126>,711:51]
[@-1,27455:27483='failedVerificationSlashAmount',<125>,724:25]
[@-1,27484:28022='");\r\n    }\r\n\r\n    /*\r\n     * @dev Set missed verification slash amount. Only callable by the controller owner\r\n     * @param _missedVerificationSlashAmount % of stake slashed for missed verification\r\n     */\r\n    function setMissedVerificationSlashAmount(uint256 _missedVerificationSlashAmount) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_missedVerificationSlashAmount));\r\n\r\n        missedVerificationSlashAmount = _missedVerificationSlashAmount;\r\n\r\n        ParameterUpdate("',<126>,724:54]
[@-1,28023:28051='missedVerificationSlashAmount',<125>,737:25]
[@-1,28052:28589='");\r\n    }\r\n\r\n    /*\r\n     * @dev Set double claim slash amount. Only callable by the controller owner\r\n     * @param _doubleClaimSegmentSlashAmount % of stake slashed for double claiming a segment\r\n     */\r\n    function setDoubleClaimSegmentSlashAmount(uint256 _doubleClaimSegmentSlashAmount) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_doubleClaimSegmentSlashAmount));\r\n\r\n        doubleClaimSegmentSlashAmount = _doubleClaimSegmentSlashAmount;\r\n\r\n        ParameterUpdate("',<126>,737:54]
[@-1,28590:28618='doubleClaimSegmentSlashAmount',<125>,750:25]
[@-1,28619:47891='");\r\n    }\r\n\r\n    /*\r\n     * @dev Set finder fee. Only callable by the controller owner\r\n     * @param _finderFee % of slashed amount awarded to finder\r\n     */\r\n    function setFinderFee(uint256 _finderFee) external onlyControllerOwner {\r\n        // Must be a valid percentage\r\n        require(MathUtils.validPerc(_finderFee));\r\n\r\n        finderFee = _finderFee;\r\n    }\r\n\r\n    /*\r\n     * @dev Deposit ETH for jobs\r\n     */\r\n    function deposit() external payable whenSystemNotPaused {\r\n        broadcasters[msg.sender].deposit = broadcasters[msg.sender].deposit.add(msg.value);\r\n        // Transfer ETH for deposit to Minter\r\n        minter().depositETH.value(msg.value)();\r\n\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    /*\r\n     * @dev Withdraw deposited funds\r\n     */\r\n    function withdraw() external whenSystemNotPaused {\r\n        // Can only withdraw at or after the broadcster's withdraw block\r\n        require(broadcasters[msg.sender].withdrawBlock <= roundsManager().blockNum());\r\n\r\n        uint256 amount = broadcasters[msg.sender].deposit;\r\n        delete broadcasters[msg.sender];\r\n        minter().trustedWithdrawETH(msg.sender, amount);\r\n\r\n        Withdraw(msg.sender);\r\n    }\r\n\r\n    /*\r\n     * @dev Submit a transcoding job\r\n     * @param _streamId Unique stream identifier\r\n     * @param _transcodingOptions Output bitrates, formats, encodings\r\n     * @param _maxPricePerSegment Max price (in LPT base units) to pay for transcoding a segment of a stream\r\n     * @param _endBlock Block at which this job becomes inactive\r\n     */\r\n    function job(string _streamId, string _transcodingOptions, uint256 _maxPricePerSegment, uint256 _endBlock)\r\n        external\r\n        whenSystemNotPaused\r\n    {\r\n        uint256 blockNum = roundsManager().blockNum();\r\n\r\n        // End block must be in the future\r\n        require(_endBlock > blockNum);\r\n        // Transcoding options must be valid\r\n        require(JobLib.validTranscodingOptions(_transcodingOptions));\r\n\r\n        Job storage job = jobs[numJobs];\r\n        job.jobId = numJobs;\r\n        job.streamId = _streamId;\r\n        job.transcodingOptions = _transcodingOptions;\r\n        job.maxPricePerSegment = _maxPricePerSegment;\r\n        job.broadcasterAddress = msg.sender;\r\n        job.creationRound = roundsManager().currentRound();\r\n        job.creationBlock = blockNum;\r\n        job.endBlock = _endBlock;\r\n\r\n        NewJob(\r\n            msg.sender,\r\n            numJobs,\r\n            _streamId,\r\n            _transcodingOptions,\r\n            _maxPricePerSegment,\r\n            blockNum\r\n        );\r\n\r\n        // Increment number of created jobs\r\n        numJobs = numJobs.add(1);\r\n\r\n        if (_endBlock > broadcasters[msg.sender].withdrawBlock) {\r\n            // Set new withdraw block if job end block is greater than current\r\n            // broadcaster withdraw block\r\n            broadcasters[msg.sender].withdrawBlock = _endBlock;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Submit claim for a range of segments\r\n     * @param _jobId Job identifier\r\n     * @param _segmentRange Range of claimed segments\r\n     * @param _claimRoot Merkle root of transcoded segment proof data for claimed segments\r\n     */\r\n    function claimWork(uint256 _jobId, uint256[2] _segmentRange, bytes32 _claimRoot)\r\n        external\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n\r\n        // Job cannot be inactive\r\n        require(jobStatus(_jobId) != JobStatus.Inactive);\r\n        // Segment range must be valid\r\n        require(_segmentRange[1] >= _segmentRange[0]);\r\n        // Caller must be registered transcoder\r\n        require(bondingManager().isRegisteredTranscoder(msg.sender));\r\n\r\n        uint256 blockNum = roundsManager().blockNum();\r\n\r\n        if (job.transcoderAddress != address(0)) {\r\n            // If transcoder already assigned, check if sender is\r\n            // the assigned transcoder\r\n            require(job.transcoderAddress == msg.sender);\r\n        } else {\r\n            // If transcoder is not already assigned, check if sender should be assigned\r\n            // roundsManager.blockHash() will ensure that the job creation block has been mined and it has not\r\n            // been more than 256 blocks since the creation block\r\n            require(bondingManager().electActiveTranscoder(job.maxPricePerSegment, roundsManager().blockHash(job.creationBlock), job.creationRound) == msg.sender);\r\n\r\n            job.transcoderAddress = msg.sender;\r\n        }\r\n\r\n        // Move fees from broadcaster deposit to escrow\r\n        uint256 fees = JobLib.calcFees(_segmentRange[1].sub(_segmentRange[0]).add(1), job.transcodingOptions, job.maxPricePerSegment);\r\n        broadcasters[job.broadcasterAddress].deposit = broadcasters[job.broadcasterAddress].deposit.sub(fees);\r\n        job.escrow = job.escrow.add(fees);\r\n\r\n        uint256 endVerificationBlock = blockNum.add(verificationPeriod);\r\n        uint256 endVerificationSlashingBlock = endVerificationBlock.add(verificationSlashingPeriod);\r\n\r\n        job.claims.push(\r\n            Claim({\r\n                claimId: job.claims.length,\r\n                segmentRange: _segmentRange,\r\n                claimRoot: _claimRoot,\r\n                claimBlock: blockNum,\r\n                endVerificationBlock: endVerificationBlock,\r\n                endVerificationSlashingBlock: endVerificationSlashingBlock,\r\n                status: ClaimStatus.Pending\r\n           })\r\n        );\r\n\r\n        NewClaim(job.transcoderAddress, _jobId, job.claims.length - 1);\r\n    }\r\n\r\n    /*\r\n     * @dev Submit transcode receipt and invoke transcoding verification\r\n     * @param _jobId Job identifier\r\n     * @param _segmentNumber Segment sequence number in stream\r\n     * @param _dataStorageHash Content-addressed storage hash of segment data\r\n     * @param _dataHashes Hash of segment data and hash of transcoded segment data\r\n     * @param _broadcasterSig Broadcaster's signature over segment hash\r\n     * @param _proof Merkle proof for transcode receipt\r\n     */\r\n    function verify(\r\n        uint256 _jobId,\r\n        uint256 _claimId,\r\n        uint256 _segmentNumber,\r\n        string _dataStorageHash,\r\n        bytes32[2] _dataHashes,\r\n        bytes _broadcasterSig,\r\n        bytes _proof\r\n    )\r\n        external\r\n        payable\r\n        whenSystemNotPaused\r\n        sufficientPayment\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n\r\n        // Sender must be elected transcoder\r\n        require(job.transcoderAddress == msg.sender);\r\n\r\n        uint256 challengeBlock = claim.claimBlock + 1;\r\n        // Segment must be eligible for verification\r\n        // roundsManager().blockHash() ensures that the challenge block is within the last 256 blocks from the current block\r\n        require(JobLib.shouldVerifySegment(_segmentNumber, claim.segmentRange, challengeBlock, roundsManager().blockHash(challengeBlock), verificationRate));\r\n        // Segment must be signed by broadcaster\r\n        require(\r\n            JobLib.validateBroadcasterSig(\r\n                job.streamId,\r\n                _segmentNumber,\r\n                _dataHashes[0],\r\n                _broadcasterSig,\r\n                job.broadcasterAddress\r\n            )\r\n        );\r\n        // Receipt must be valid\r\n        require(\r\n            JobLib.validateReceipt(\r\n                job.streamId,\r\n                _segmentNumber,\r\n                _dataHashes[0],\r\n                _dataHashes[1],\r\n                _broadcasterSig,\r\n                _proof,\r\n                claim.claimRoot\r\n           )\r\n        );\r\n\r\n        // Mark segment as submitted for verification\r\n        claim.segmentVerifications[_segmentNumber] = true;\r\n\r\n        // Invoke transcoding verification. This is async and will result in a callback to receiveVerification() which is implemented by this contract\r\n        invokeVerification(_jobId, _claimId, _segmentNumber, _dataStorageHash, _dataHashes);\r\n\r\n        Verify(msg.sender, _jobId, _claimId, _segmentNumber);\r\n    }\r\n\r\n    /*\r\n     * @dev Invoke transcoding verification by calling the Verifier contract\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     * @param _segmentNumber Segment sequence number in stream\r\n     * @param _dataStorageHash Content addressable storage hash of segment data\r\n     * @param _dataHashes Hash of segment data and hash of transcoded segment data\r\n     */\r\n    function invokeVerification(\r\n        uint256 _jobId,\r\n        uint256 _claimId,\r\n        uint256 _segmentNumber,\r\n        string _dataStorageHash,\r\n        bytes32[2] _dataHashes\r\n    )\r\n        internal\r\n    {\r\n        IVerifier verifierContract = verifier();\r\n\r\n        uint256 price = verifierContract.getPrice();\r\n\r\n        // Send payment to verifier if price is greater than zero\r\n        if (price > 0) {\r\n            verifierContract.verify.value(price)(\r\n                _jobId,\r\n                _claimId,\r\n                _segmentNumber,\r\n                jobs[_jobId].transcodingOptions,\r\n                _dataStorageHash,\r\n                _dataHashes\r\n            );\r\n        } else {\r\n            // If price is 0, reject any value transfers\r\n            require(msg.value == 0);\r\n\r\n            verifierContract.verify(\r\n                _jobId,\r\n                _claimId,\r\n                _segmentNumber,\r\n                jobs[_jobId].transcodingOptions,\r\n                _dataStorageHash,\r\n                _dataHashes\r\n            );\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Callback function that receives the results of transcoding verification\r\n     * @param _jobId Job identifier\r\n     * @param _segmentNumber Segment being verified for job\r\n     * @param _result Boolean result of whether verification succeeded or not\r\n     */\r\n    function receiveVerification(uint256 _jobId, uint256 _claimId, uint256 _segmentNumber, bool _result)\r\n        external\r\n        whenSystemNotPaused\r\n        onlyVerifier\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n        // Claim must not be slashed\r\n        require(claim.status != ClaimStatus.Slashed);\r\n        // Segment must have been submitted for verification\r\n        require(claim.segmentVerifications[_segmentNumber]);\r\n\r\n        address transcoder = job.transcoderAddress;\r\n\r\n        if (!_result) {\r\n            // Refund broadcaster\r\n            refundBroadcaster(_jobId);\r\n            // Set claim as slashed\r\n            claim.status = ClaimStatus.Slashed;\r\n            // Protocol slashes transcoder for failing verification (no finder)\r\n            bondingManager().slashTranscoder(transcoder, address(0), failedVerificationSlashAmount, 0);\r\n\r\n            FailedVerification(transcoder, _jobId, _claimId, _segmentNumber);\r\n        } else {\r\n            PassedVerification(transcoder, _jobId, _claimId, _segmentNumber);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Distribute fees for multiple claims\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     */\r\n    function batchDistributeFees(uint256 _jobId, uint256[] _claimIds)\r\n        external\r\n        whenSystemNotPaused\r\n    {\r\n        for (uint256 i = 0; i < _claimIds.length; i++) {\r\n            distributeFees(_jobId, _claimIds[i]);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Slash transcoder for missing verification\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     * @param _segmentNumber Segment that was not verified\r\n     */\r\n    function missedVerificationSlash(uint256 _jobId, uint256 _claimId, uint256 _segmentNumber)\r\n        external\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n\r\n        uint256 blockNum = roundsManager().blockNum();\r\n        uint256 challengeBlock = claim.claimBlock + 1;\r\n        // Must be after verification period\r\n        require(blockNum >= claim.endVerificationBlock);\r\n        // Must be before end of slashing period\r\n        require(blockNum < claim.endVerificationSlashingBlock);\r\n        // Claim must be pending\r\n        require(claim.status == ClaimStatus.Pending);\r\n        // Segment must be eligible for verification\r\n        // roundsManager().blockHash() ensures that the challenge block is within the last 256 blocks from the current block\r\n        require(JobLib.shouldVerifySegment(_segmentNumber, claim.segmentRange, challengeBlock, roundsManager().blockHash(challengeBlock), verificationRate));\r\n        // Transcoder must have missed verification for the segment\r\n        require(!claim.segmentVerifications[_segmentNumber]);\r\n\r\n        refundBroadcaster(_jobId);\r\n\r\n        // Slash transcoder and provide finder params\r\n        bondingManager().slashTranscoder(job.transcoderAddress, msg.sender, missedVerificationSlashAmount, finderFee);\r\n\r\n        // Set claim as slashed\r\n        claim.status = ClaimStatus.Slashed;\r\n    }\r\n\r\n    /*\r\n     * @dev Slash transcoder for claiming a segment twice\r\n     * @param _jobId Job identifier\r\n     * @param _claimId1 Claim 1 identifier\r\n     * @param _claimId2 Claim 2 identifier\r\n     * @param _segmentNumber Segment that was claimed twice\r\n     */\r\n    function doubleClaimSegmentSlash(\r\n        uint256 _jobId,\r\n        uint256 _claimId1,\r\n        uint256 _claimId2,\r\n        uint256 _segmentNumber\r\n    )\r\n        external\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim1 = job.claims[_claimId1];\r\n        Claim storage claim2 = job.claims[_claimId2];\r\n\r\n        // Claim 1 must not be slashed\r\n        require(claim1.status != ClaimStatus.Slashed);\r\n        // Claim 2 must not be slashed\r\n        require(claim2.status != ClaimStatus.Slashed);\r\n        // Segment must be in claim 1 segment range\r\n        require(_segmentNumber >= claim1.segmentRange[0] && _segmentNumber <= claim1.segmentRange[1]);\r\n        // Segment must be in claim 2 segment range\r\n        require(_segmentNumber >= claim2.segmentRange[0] && _segmentNumber <= claim2.segmentRange[1]);\r\n\r\n        // Slash transcoder and provide finder params\r\n        bondingManager().slashTranscoder(job.transcoderAddress, msg.sender, doubleClaimSegmentSlashAmount, finderFee);\r\n\r\n        refundBroadcaster(_jobId);\r\n\r\n        // Set claim 1 as slashed\r\n        claim1.status = ClaimStatus.Slashed;\r\n        // Set claim 2 as slashed\r\n        claim2.status = ClaimStatus.Slashed;\r\n    }\r\n\r\n    /*\r\n     * @dev Distribute fees for a particular claim\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     */\r\n    function distributeFees(uint256 _jobId, uint256 _claimId)\r\n        public\r\n        whenSystemNotPaused\r\n        jobExists(_jobId)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n        Claim storage claim = job.claims[_claimId];\r\n\r\n        // Sender must be elected transcoder for job\r\n        require(job.transcoderAddress == msg.sender);\r\n        // Claim must not be complete\r\n        require(claim.status == ClaimStatus.Pending);\r\n        // Slashing period must be over for claim\r\n        require(claim.endVerificationSlashingBlock <= roundsManager().blockNum());\r\n\r\n        uint256 fees = JobLib.calcFees(claim.segmentRange[1].sub(claim.segmentRange[0]).add(1), job.transcodingOptions, job.maxPricePerSegment);\r\n        // Deduct fees from escrow\r\n        job.escrow = job.escrow.sub(fees);\r\n        // Add fees to transcoder's fee pool\r\n        bondingManager().updateTranscoderWithFees(msg.sender, fees, job.creationRound);\r\n\r\n        // Set claim as complete\r\n        claim.status = ClaimStatus.Complete;\r\n\r\n        DistributeFees(msg.sender, _jobId, _claimId, fees);\r\n    }\r\n\r\n    /*\r\n     * @dev Compute status of job\r\n     * @param _jobId Job identifier\r\n     */\r\n    function jobStatus(uint256 _jobId) public view returns (JobStatus) {\r\n        if (jobs[_jobId].endBlock <= roundsManager().blockNum()) {\r\n            // A job is inactive if the current block is greater than or equal to the job's end block\r\n            return JobStatus.Inactive;\r\n        } else {\r\n            // A job is active if the current block is less than the job's end block\r\n            return JobStatus.Active;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Return job info\r\n     * @param _jobId Job identifier\r\n     */\r\n    function getJob(\r\n        uint256 _jobId\r\n    )\r\n        public\r\n        view\r\n        returns (string streamId, string transcodingOptions, uint256 maxPricePerSegment, address broadcasterAddress, address transcoderAddress, uint256 creationRound, uint256 creationBlock, uint256 endBlock, uint256 escrow, uint256 totalClaims)\r\n    {\r\n        Job storage job = jobs[_jobId];\r\n\r\n        streamId = job.streamId;\r\n        transcodingOptions = job.transcodingOptions;\r\n        maxPricePerSegment = job.maxPricePerSegment;\r\n        broadcasterAddress = job.broadcasterAddress;\r\n        transcoderAddress = job.transcoderAddress;\r\n        creationRound = job.creationRound;\r\n        creationBlock = job.creationBlock;\r\n        endBlock = job.endBlock;\r\n        escrow = job.escrow;\r\n        totalClaims = job.claims.length;\r\n    }\r\n\r\n    /*\r\n     * @dev Return claim info\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     */\r\n    function getClaim(\r\n        uint256 _jobId,\r\n        uint256 _claimId\r\n    )\r\n        public\r\n        view\r\n        returns (uint256[2] segmentRange, bytes32 claimRoot, uint256 claimBlock, uint256 endVerificationBlock, uint256 endVerificationSlashingBlock, ClaimStatus status)\r\n    {\r\n        Claim storage claim = jobs[_jobId].claims[_claimId];\r\n\r\n        segmentRange = claim.segmentRange;\r\n        claimRoot = claim.claimRoot;\r\n        claimBlock = claim.claimBlock;\r\n        endVerificationBlock = claim.endVerificationBlock;\r\n        endVerificationSlashingBlock = claim.endVerificationSlashingBlock;\r\n        status = claim.status;\r\n    }\r\n\r\n    /*\r\n     * @dev Return whether a segment was verified for a claim\r\n     * @param _jobId Job identifier\r\n     * @param _claimId Claim identifier\r\n     * @param _segmentNumber Segment number\r\n     */\r\n    function isClaimSegmentVerified(\r\n        uint256 _jobId,\r\n        uint256 _claimId,\r\n        uint256 _segmentNumber\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return jobs[_jobId].claims[_claimId].segmentVerifications[_segmentNumber];\r\n    }\r\n\r\n    /*\r\n     * @dev Refund broadcaster for a job\r\n     * @param _jobId Job identifier\r\n     */\r\n    function refundBroadcaster(uint256 _jobId) internal {\r\n        Job storage job = jobs[_jobId];\r\n\r\n        // Return all escrowed fees for a job\r\n        uint256 fees = job.escrow;\r\n        job.escrow = job.escrow.sub(fees);\r\n        broadcasters[job.broadcasterAddress].deposit = broadcasters[job.broadcasterAddress].deposit.add(fees);\r\n        // Set end block of job to current block - job becomes inactive\r\n        job.endBlock = roundsManager().blockNum();\r\n    }\r\n\r\n    /*\r\n     * @dev Returns Minter\r\n     */\r\n    function minter() internal view returns (IMinter) {\r\n        return IMinter(controller.getContract(keccak256("',<126>,750:54]
[@-1,47892:47897='Minter',<125>,1264:57]
[@-1,47898:48104='")));\r\n    }\r\n\r\n    /*\r\n     * @dev Returns BondingManager\r\n     */\r\n    function bondingManager() internal view returns (IBondingManager) {\r\n        return IBondingManager(controller.getContract(keccak256("',<126>,1264:63]
[@-1,48105:48118='BondingManager',<125>,1271:65]
[@-1,48119:48321='")));\r\n    }\r\n\r\n    /*\r\n     * @dev Returns RoundsManager\r\n     */\r\n    function roundsManager() internal view returns (IRoundsManager) {\r\n        return IRoundsManager(controller.getContract(keccak256("',<126>,1271:79]
[@-1,48322:48334='RoundsManager',<125>,1278:64]
[@-1,48335:48517='")));\r\n    }\r\n\r\n    /*\r\n     * @dev Returns Verifier\r\n     */\r\n    function verifier() internal view returns (IVerifier) {\r\n        return IVerifier(controller.getContract(keccak256("',<126>,1278:77]
[@-1,48518:48525='Verifier',<125>,1285:59]
